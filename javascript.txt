JavaScript编程教程

在html文档中添加JavaScript指令:
<script type="text/javascript"></script>
javascript代码执行顺序：从上往下执行js代码

一、javascript的基本输出语言
1、控制浏览器弹出一个警告框:alert("文字")
注释:alert意思是警告，即在网页中弹出警告框
2、在html文档的body中添加内容(在文档中写入内容):
document.write("内容")
注释:document意思是文档，即html中的文档，.write意思是写
3、向控制台输入一个内容(用户在浏览器无法看见)
console.log("文字")
注释：console的意思是控制台
作用：console.log的作用是向控制台输出一个内容

二、JS代码编写位置
1、可以将js代码编写到html标签onclick的属性中，当我们点击时js代码才会执行
虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用
示例:<button onclick="alert=('文字');">
注释:button是html标签代码，意思是按钮，可以生成一个按钮
注意:(1)、括号内文字使用的是单引号'，因为外面html标签中已使用过双引号"了
(2)、这段代码结束后依然需要；来结束这段代码
2、可以将js代码写在超链接的href的属性中，这样当点击超链接时，会执行js代码
格式:<a href="javascript:js代码;"></a>
注释:(1)、<a href="">是html代码的标签，意思是插入超链接
(2)、在双引号"内必须先写入javascript:，在:后面写入js代码才能生效,如果在:后面没有任何js代码，那么点击超链接不会有任何反应
3、可以将js代码写到script标签中
格式:<script type="text/javascript">
     js代码
     </script>
4、可以将js代码编写到外部js文件中然后通过script标签引入
好处:写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制
推荐的使用方式
格式:<script type="text/javascript" src="外部js文件地址"></script>
注释:(1)<script type="text/javascript" src="js文件地址">标签可以引入外部文件
提示:script标签一旦用于引入外部文件，就不能在编写代码了，即时编写浏览器也会忽略，如果需要可以在创建一个新的script标签用于编写内部代码

三、js的基础语法
1、注释
多行注释，是一种js注释，注释中的内容不会被执行，但是可以在源代码中查看
格式:/*
     */
规则:以/*开始，以*/结束
单行注释
格式://    
规则:只有//后面的一行是注释，其他地方不是
要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的调试
js语法的基本规则
1、js中严格区分大小写Alert≠alert
2、js中每一条语句以分号(;)结尾
   ------如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，
           而且有些时候，浏览器会加错分号，所以开发中分号必须写
3、js中会忽略多个空格和换行，所以我们可以利用空格和换行来对代码进行格式化

四、字面量和变量
1、字面量，都是一些不可改变的值
           比如:1 2 3 4 5
           字面量都是可以直接使用的，但是我们一般都不会直接使用字面量
2、变量，可以用来保存字面量，而且变量的值是可以任意改变的
           变量更加方便我们使用，所以开发中都是用变量去保存一个字面量，
           而很少直接使用字面量
           可以通过变量对字面量进行描述
例如X=123456789    X是变量，123456789是字面量
3、声明变量
   在js中使用var关键字来声明一个变量
使用方式:
例如:var a;
变量a可以直接使用
例如:console.log(a)
4、为变量赋值
例如:a=123
5、声明和赋值同时进行
例如:var b=123456789;
6、使用变量对字面量进行描述
例如:var age=14
意思为年龄是14岁

五、标识符
    ━ 在js中所有可以由我们自主命名的都可以称为是标识符
    ━例如:变量名、函数名、属性名都属于标识符
    ━命名一个标识符时需要遵守如下的规则:
      1.标识符中只可以含有字母、数字、_、$
    例如:var a_1_$ =123;
        console.log(a_1_$);
      2.标识符不能以数字开头
    错误示范
    var 1 =123
    console.log(1)
      3.标识符不能是JS中的关键字或保留字
    错误示范
    var var =123;
    console.log(var)
      4.标识符一般都采用驼峰命名法
        ━首字母小写，每个单词开头字母大写，其余字母小写
          示例:helloworld━helloWorld
          基本格式:xxxYyyZzz
━补充内容:JS底层保存标识符时实际上是采用的Unicode编码
      所以理论上讲，所有UTF-8中含有的内容都可以作为标识符
   ━所以其实标识符可以是中文，但是千万不要这么用

六、数据类型
数据类型指的就是字面量的类型
  在js中一共有六种数据类型
        String     字符串
        Number     数值
        Boolean   布尔值
        Null       空值
        Undefined 未定义
        Object     对象
其中String Number Boolean Null Undefined属于基本数据类型
 而Object属于引用数据类型

1、String字符串
    ━在JS中字符串需要使用引号引起来
    ━使用双引号或单引号都可以，但是不要混着用
    ━引号不能嵌套，双引号中不能放双引号，单引号里面不能放单引号
例如:
var str ="hello";
console.log(str);
例如:
var str ='hello';
console.log(str);
错误示范
var str ='hello";
错误示范
var str ="我说:"今天天气不错！""
在字符串中，我们可以使用\作为转义字符
     当表示一些特殊符号时可以使用\进行转义
     \"表示"
     \'表示'
     \n表示换行
     \t表示制表符
     \\表示\
示例:
var str ="我说:\"今天天气真不错！\""
额外补充:
alert("str")表示输出字符串str
alert(str) 表示输出变量str

2、数值  Number
在JS中所有的数值都是Number类型，
  包括整数和浮点数(小数)
  可以使用一个运算符typeof来检查一个变量的类型
    语法:typeof 变量
        检查字符串时，会返回string
        检查数值时，会返回number
JS中可以表示的数字最大值
     Number.MAX_VALUE
示例：var a=Number.MAX_VALUE;
如果使用Number表示的数字超过了最大值，则会返回一个Infinity  表示正无穷
    使用typeof检查Infinity也会返回number
示例：var a=Infinity;
NaN 是一个特殊的数字，表示Not A Number
     使用typeof检查NaN，会返回number
示例：var a=NaN;
Number.MIN_VALUE表示JS中0以上的最小值
示例：var a=Number.MIN_VALUE;
在JS中，整数的运算基本可以保证精确
    如果使用JS进行浮点数计算，可能得到一个不精确的结果
        所以千万不要使用JS进行对精确度要求比较高的运算
示例:var a=1+1

3、布尔值  Boolean
布尔值只有两个，主要用来做逻辑判断
true
   ━表示真
false
   ━表示假
示例：var a=true;console.log(typeof a)
使用typeof检查布尔值时，会返回boolean

4、Null和 Undefined
Null类型的值只有一个，就是null
    null这个值专门用来表示一个为空的对象
    使用typeof检查一个null值时，会返回object
    Undefined类型的值只有一个，就是undefined
当声明一个变量，但是并不给它赋值时，它的值就是undefined
    使用typeof检查一个undefined时也会返回一个undefined
    
5、强制类型转换
   ━指将一个数据类型强制转换为其他数据类型
   ━类型转换主要指将其他的数据类型转换为
         String Number Boolean
    
    ①将其他的数据类型转换为String
    方式一：
       ━调用被转换类型的toString()方法
       ━该方法不会影响到原变量，它会将转换的结果返回
       ━但是注意：null和undefined这两个值没有toString()的方法
            如果调用他们的方法，会报错
    方式二：
       ━调用String()函数，并将被转换的数据作为参数传递给函数
       ━使用String()函数做强制类型转换时，
             对于Number和Boolean实际上就是调用toString()方法
             但是对于Null 和 Undefined，就不会调用toString()方法
                 它会将null直接转换为"null"
                 将undefined转换为"undefined"
    调用XXX()  函数就是  XXX()
    示例：var a=123
          a=String(a)
    拓展：调用XXX的YYY方法，就相当于xxx.yyy()
    示例：调用a的toString()方法
    var a=123;
    a=a.toString();
    原理：把a的类型转换为String，再把转换后a的类型赋值给a，以实现将a的数据类型转换为string
    
    ②将其他数据类型转换为Number
    转换方式一：
        调用Number()函数
    示例：var a="123"
    a=Number(a)
    ━字符串--→数字
    1.如果是纯数字的字符串，则直接将其转换为数字
    2.如果字符串中由非数字的内容，则转换为NaN
    3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
    ━布尔--→数字
    1.true转成1
    2.false转成0
    ━Null--→数字 ==0
    ━Undefined--→数字   NaN
    转换方式二：
    ━这种方式专门用来对付字符串
          ━把一个字符串转换为一个整数    parseInt()
    parseInt()可以将一个字符串中的有效整数内容取出来，然后转换为Number
    示例：var a="123a";a=parseInt(a);
          ━把一个字符串转换为一个符点数  parseFloat()
    parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数
    示例：var a="123.1";a=parseFloat(a);
    如果对非String使用parseInt()或parseFloat()
        他会先将其转换为String，然后再进行操作
    示例：var a=true;a=parseInt(a);
    
    拓展：其他进制数字
    在JS中，如果需要表示16进制的数字，则需要以0X开头
              如果需要表示8进制的数字，则需要以0o开头
              如果需要表示二进制的数字，则需要以0b开头
      但是许多浏览器不支持2进制
    像"070"这种字符串，有些浏览器会当成8进制解析，有些会当成10进制解析
    可以在parseInt()中传递第二个参数来指定数字的进制
    示例：var a="040";a=parseInt(a,10);
    
    ③将其他数据类型转换为Boolean
        ━使用Boolean()函数
            ━数字--→布尔值
              除了0和NaN，其余的都是true
            ━字符串--->布尔值
              除了空串，其余的都是true
            ━Null--->布尔值  false
            ━Undefined--->布尔值  false
            ━对象也会转换为true
    
七、运算符
    通过运算符可以对一个或多个值进行运算
    比如：typeof就是运算符，可以用来获得一个值得类型
          它会将该值的类型以字符串的形式返回
    
    1、算数运算符
    当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算
    任何值和NaN做运算，最后结果都是NaN
    +   可以将两个值进行加法运算，并将结果返回
         如果对两个字符串进行加法运算，则会做拼串
             会将两个字符串拼接为一个字符串，并返回
         任何值和字符串做加法运算，都会先转换为字符串，然后和再和字符串做拼串的操作
         我们可以利用这一特点来将任意一个数据类型转换为String
         格式：任意一个数据类型+""  即可将其转换为String
    输出结果：var a=123+"";console.log("a="+a);
    -    可以将两个值进行减法运算，并将结果返回
    *    可以对两个值进行乘法运算，并将结果返回
    /    可以对两个值进行除法运算，并将结果返回
    任何值做-*/运算时都会自动转换为Number
    可以利用这个特点做类型转换
    格式：一个值 -0 *1 /1 来将其转换为Number
    原理和Number()函数一样
    %   取模运算(取余数)
    示例：var a=9%2;
    结果会输出为1
    
    2、一元运算符
    只需要一个操作数
    +  正号  -  负号
    ━正号不会对数字产生任何影响
    ━负号可以对数字进行负号取反
    对于非Number值
    ━它会将其转换为Number再进行运算
    可以对任意数据类型使用+，来将其转换为Number
    示例：var a="123";a=+a;
    
    3、自增和自减
    自增 ++
    自增可以在变量自身上增加1
    变量自增后，原变量的值会立即自增1
    两种自增：后++(a++)和前++(++a)
    都会使原变量加1
    不同：a++  和  ++a  的值不同
    a++的值等于原变量原来的值(自增前的值)
    ++a的值等于原变量增加后的值(自增后的值)
    示例：var a=1;a=a++;
    
    自减--
    变量在自身基础上-1
    两种自减：前++(--a)和后--(a--)
    示例：var num=10;num--;
    都可以将原变量-1
    不同的是a--和--a的值不同
    a--是-1之前的值
    --a是-1后的值
    
    4、逻辑运算符
    三种逻辑运算符
    !   非
    对一个值进行非运算
    非运算就是对布尔值进行取反  比如true变成false
    对一个值进行两次取反，它不会变化
    运算非布尔值就会把它转换为布尔值再取反
    其它数据类型转换为布尔值：
    var a=1;a=!!a;
    && 与
    可以对符号两侧的值进行与运算并返回
    与运算规则：只要有一个值为false就返回false，都为true时返回true
    JS中的“与”是短路的与，只要第一个值是false，就不会看第二个值
    ||  或
    可以对两个符号进行或运算并返回结果
    两个值只要有一个true就返回true
    JS中的“或”属于短路的或，如果第一个值是true则不会检查第二个值
    
    5、非布尔值的与和或
    会先转换为布尔值运算，但是会返回原值
    与：
        如果第一个值为true，则返回第二个值
        如果第一个值为false，则返回第一个值
        如果都是true，则返回后边的
        如果有false，则返回false
        如果都是false，则返回前边的
    或：
        如果第一个值为true，则返回第一个值
        如果第一个值为false，则返回第二个值
        如果都是false，则返回后边的
        如果有true，则返回false
        如果都是true，则返回前边的
    
    6、赋值运算符
    =  
    可以将符号左侧的值赋给符号右边的变量
    +=
    a+=5等价与a=a+5
    -=
    a-=5等价与a=a-5
    *=
    a*=5等价与a=a*5
    /=            %=
    
    7、关系运算符
    >大于  >=大于等于  <=小于等于  <小于
    若结果符合则输出true，反之输出false
    -对于非数值进行比较时，会先转换为数值再进行计算
         任何值和NaN做任何比较都是false
         如果符号两侧的值都是字符串，不会将其转换为数字进行比较
              而会分别比较字符串中字符的Unicode编码
    -比较字符编码时，是一位一位进行比较
         如果两位一样，则比较下一位，所以借用它来对英文进行排序
         比较中文是没有意义的
    -如果比较的两个字符串类型的数字，可能会得到不可预期的效果
         注意：在比较两个数字类型的字符串时，一定一定一定要转型
    
    8、Unicode编码
    在字符串中使用转义字符输入Unicode编码
          格式：\u四位编码
    在网页中使用Unicode编码
          格式：&#编码;     
          注意：这里的编码需要的是10进制
    
    9、相等运算符
    相等运算符用来比较两个值是否相等
    如果相等返回true，否则返回false
    使用==来做相等运算
    当使用==来比较两个值时，如果两个值类型不同，会把类型转换为相等的值再运算
          undefined衍生自null
              所以这两个值做相等判断时，会返回true
          NaN不和任何值相等，包括他本身
    可以通过isNaN()函数来判断一个值是否是NaN
        如果该值是NaN，则返回true，否则返回false
    示例：document.write("isNaN(NaN)")
    
    不相等
    用来判断两值是否相等
    格式：值 != 值
    相等返回false，不相等返回true
    不相等也会自动类型转换
    
    ===
    全等
    用来判断两个值是否全等，与相等类似
    不同的是它不会做类型转换
    
    !==
    不全等
    用来判断两个值是否不全等，和不等类似
    也不会自动做类型转换
    
    10、条件运算符(三元运算符)
    语法：条件表达式?语句1:语句2
    执行流程：
     条件运算符执行时，首先对条件表达式进行求值
        如果该值为true，则执行语句1，并返回结果
        如果该值为false，则执行语句2，并返回结果
    示例：var a=1;var b =2;var max=a>b?a:b;
        如果条件表达式是非布尔值，会先将其转换为布尔值再进行运算
    
    11、运算符优先级
     , 运算符
        使用,可以分割多个语句，一般在声明多个变量时使用 
    示例：var a=1,b=2;
    和数学一样，JS中也有运算符优先级
        比如：先乘除，后加减
    在JS中有一个运算优先级的表，
       表中越靠上优先级越高
       优先级一样高就从左往右算
    但是这个表我们并不需要记忆，如果遇到优先级不清楚，可以使用括号来改变优先级
    
    12、代码块
    代码是由一条一条语句构成的
    语句是按照自上而下的顺序一条一条执行的
        在JS中可以使用{}来为语句进行分组
    同一个大括号中的语句我们称为是一组语句，
    它们要么都执行，要么都不执行
    一个{}中的语句我们也称为叫一个代码块
    在代码块的后边就不用再编写;了
    
    JS中的代码块只具有分组的作用，没有其他用途
         代码块内部的内容，在外部是完全可见的
    
八、语句
    语句分类：
        1、条件判断语句
        2、条件分支语句
        3、循环语句
    
    条件判断语句
      if语句
    语法一：
      if(条件表达式){
          语句...}
    if语句在执行时会先进行求值判断，
    如果条件表达式的值为true，则会执行if后的语句
    如果条件表达式的值为false，则不会执行if后的语句
    if语句只能控制紧随其后的那个语句
    如果要if语句控制多条语句，可以将这些语句放入代码块中
    示例：var a=2;if(a>1&&a<3){alert('你妈炸了')}
    
    语法二：
    if(条件表达式){
    语句...
    }else{
    语句...
    }
    if...else...语句
    该语句在执行时，会对if后的条件表达式先进行求值判断，
    如果条件表达式的值为true，则执行if后的语句
    如果条件表达式的值为false，则执行else后的语句
    
    语法三：
    if(条件表达式){
    语句...
    }else if(条件表达式){
    语句...
    }else if(条件表达式){
    语句...
    }else{
    语句...}
    if...else if...else语句
    该语句在执行时，会从上到下依次对条件表达式先进行求值判断，
    如果条件表达式的值为true，则执行当前语句。
    如果条件表达式的值为false，则继续向下判断。
    如果所有条件都不满足，则执行最后一个else的语句
    该语句中，只会有一个代码块被执行，一旦代码块执行了则直接结束语句
    新函数：prompt()  可以弹出一个提示框，该提示框中会带有一个文本框，
         用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数
         用户输入的内容会作为函数的返回值返回，可以定义一个变量来接受该内容
         prompt()函数的返回值是String类型的
    示例：var point=prompt("请输入小明的分数")
    
    2、条件分支语句
    switch(条件表达式){
    case 表达式:
         语句...
         break;
    case 表达式:
         语句...
         break;
    default:
         语句...
         break;
    }
    执行流程：
        switch...case...语句
        在执行时会一次将case后面的表达式的值和switch后的条件表达式的值进行全等比较
              如果比较结果为true，则从当前case处开始执行代码
                  当前case后的所有代码都会执行，我们可以在case后面跟着break来停止语句
                  这样可以确保只会执行当前语句
              如果比较结果为false，则继续向下比较
    如果所有的比较结果都为false，则只执行default后面的语句
    示例：
    var a=1;
    switch(a){
        case 1:
            alert('你妈死了');
            break;
    }
    
    3、循环语句
    通过循环语句可以反复执行某段代码多次
    
    while循环
    while(条件表达式){
    语句...
    }
    执行：
    while语句在执行时，先对条件表达式进行求值判断
      如果值为true，则执行循环体，
        循环体执行完毕后，继续对表达式进行判断，
        如果值为true，则继续执行循环体，以此类推...
    如果值为false，则中止循环
        可以使用break中止循环
    示例：while(true){
    alert('1');
    if('1'){
    break;
    }
    }
    
    do...while循环
    语法：
    do{
    语句...
    }while(条件表达式)
    执行流程：
    do...while语句执行时，会先执行循环体，
        循环体执行完毕后，对while后的条件表达式进行判断，
            如果结果为true，则继续执行循环体，执行完毕后继续判断，以此类推
            如果结果为false，则终止循环
    
    for循环
    语法：
    for(初始化表达式;条件表达式;更新表达式){
    语句...
    }
    执行流程：
    1、执行初始化表达式，初始化变量
    2、执行条件表达式，判断是否循环
    3、执行更新表达式，更新表达式执行完毕，继续重复2
    示例：
    for(var a=1,a<=2,a++){
    alert('你妈死了');
    }
    
    4、break和continue
    break关键字可以用来退出switch或循环语句
      不能在if语句中使用break和continue
      break关键字会立即中止离他最近的那个循环语句
    可以为循环语句创建一个标签，来标识当前的循环
    语法：标签:循环语句
    使用break语句时，可以在break后跟着一个标签，
      这样break将会结束指定的循环，而不是最近的
    示例：
    father:
    for(var a=1;a<9;a++){
    break father;
    }
    
    continue关键字可以跳过当次循环
    同样continue也是默认只会对理他最近的循环起作用
    
    console.time("计时器的名字")可以开始用来开启一个计时器
    它需要一个字符串作为参数，这个字符串将会作为计时器的标识
    console.timeEnd()用来停止一个计时器，需要一个计时器的名字作为参数
    
    可以通过Math.sqrt()对一个数进行开方
    
九、对象
    对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性
    对象的分类：
    1、内建对象
       -由ES标准中定义的对象，在任何的ES的实现中都可以使用
    2、宿主对象
       -由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
    3、自定义对象
       -由开发人员自己创建的对象
    
1、对象的基本操作
    使用new关键字调用的函数，是构造函数constructor
      构造函数是专门用来创建对象的函数
    示例：
    var obj=new Object();
    
    在对象中保存的值称为属性
    向对象中添加属性：
     语法：对象.属性名 = 属性值;
    示例：向obj中添加一个name属性
    obj.name = "应承翰";
    
    读取对象中的属性：
     语法：对象.属性名
    示例：document.write(obj.name);
    如果读取对象中没有的属性，不会报错而是会返回undefined
    
    修改对象中的属性值：
     语法：对象.属性名 = 新值;
    示例：修改名字为黄家驹
    obj.name = "黄家驹";
    
    删除对象的属性：
     语法：delete 对象.属性名;
    示例：删除名字
    delete obj.name;
    
2、属性名和属性值
    属性名
    -对象的属性名不强制要求遵守标识符的规范
    如果要使用特殊的属性名，不能采用.的方式来操作
      需要使用另一种方式:
           语法：对象["属性名"] = 属性值;
      读取时也需要采用这种方式
    示例：
    var obj=new Object();
    obj["你妈死了"] = "你也一样";
    document.write(obj["你妈死了"]);
    
    使用[]这种形式去操作属性，更加灵活
    在[]中可以直接传递一个变量,这样变量值是多少就会读取那个属性
    示例：
    var a = "你妈死了";
    document.write(obj[a]);
    
    属性值
     JS对象的属性值可以是任意的数据类型
           甚至也可以是一个对象和函数
    示例:
    var pig = new Object();
    var monkey = new Object();
    monkey.father = pig;
    document.write(monkey.father);
    
    in运算符
    -通过该运算符可以检查一个对象中是否含有指定的属性
        如果有返回true，否则返回false
    -语法：
         "属性名" in 对象
    示例：检查monkey里是否有a
    document.write("a" in monkey);
    
3、对象字面量
    使用对象字面量来创建一个对象
    语法：var obj = {};
      使用对象字面量可以在创建对象时，直接指定对象中的属性
        对象字面量的属性名可以加引号，也可以不加
     如果要使用特殊的属性名，则必须加引号
      属性名和属性值是一组名值对结构，
         名和值之间使用:连接，多个名值对之间使用,隔开
         如果一个属性之后没有其他属性了，就不要写,
    语法：{属性名:属性值,属性名:属性值,...}
    示例：
    var obj = {
    name:"应承翰",
    age:98,
    gender:"女"
    }
    
4、函数
    -函数也是一个对象
    -函数中可以封装一些功能，在需要时可以执行这些功能
    -函数中可以保存一些代码，在需要时调用
    使用typeof检查函数时，会返回function
    
    创建函数对象
    var fun = new Function();
    可以将要封装的代码以字符串的形式传递给函数
    示例：
    var fun = new Function("document.write('你妈死了！');");
    封装到函数中的代码不会立即执行
    函数中的代码会在函数调用时执行
    调用函数  语法：函数对象()
    当调用函数时，函数中封装的代码会按照顺序执行
    示例：调用fun函数对象
    fun();
    
    使用函数声明来创建一个函数
     语法：
          function 函数名([形参1,形参2,...,形参n]){
          语句...
          }
    示例：
    function ych(){
    document.write("你妈死了！");
    }
    
    使用函数表达式
    var 函数名 = function([形参1,形参2,...,形参n]){
          语句...
          };
    
5、函数的参数
    可以在函数的()内来指定一个或多个形参(形式参数)
      对个形参之间使用,隔开，声明形参就相当于在函数内部声明了对于的变量
      但是并不赋值
    在调用函数时，可以在()内指定实参(实际参数)
     实参将会赋值给对函数中对应的形参
    调用函数时解析器不会检查实参的类型，也不会检查实参的数量，多余的实参不会被赋值，
      如果实参的数量少于形参，则没有对于实参的形参将是undefined
      函数的实参可以是任意的数据类型
    示例：
    function a(a,b){
    document.write("你妈死了！");
    }
    a(1,"你妈死了😭")
    
6、函数的返回值
    可以使用return来设置函数的返回值
      语法：
          return 值
    return后的值将会作为函数的执行结果返回，
    可以定义一个变量，来接受该结果
    在函数中return后的语句不会执行
    如果return语句后的不跟任何值则会返回undefined，
    如果函数中不写return，也会返回undefined
    return后可以跟任意类型的值
    示例：
    function a(a,b){
    var d=a+b;
    return d;
    }
    var e=a(4,5);
    
7、立即执行函数
    函数定义完，立即被调用，这种函数叫做立即执行函数
    立即执行函数往往只会执行一次
    格式：(function(){
    
    })()
    
8、枚举对象中的属性
    使用for...in  语句
    语法：
    for(var 变量 in 对象){
    
    }
    for...in语句  对象中有几个属性，循环体就会执行几次
    每次执行时，会将对象中的一个属性的名字赋值给变量
    
9、作用域
    -作用域指一个变量的作用范围
    -在JS中一共有两种作用域：
    1、全局作用域
        -直接编写在script标签中的JS代码，都在全局作用域
        -全局作用域在页面打开时创建，在页面关闭时销毁
        -在全局作用域中有一个全局对象window，
         它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
        -在全局作用域中：
            创建的变量都会作为window对象的属性保存
            创建的函数都会作为window对象的方法保存
        -全局作用域中变量都是全局变量，在页面任意位置都访问的到
    2、函数作用域
        -调用函数时创建函数作用域，执行玩后销毁
        -每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
        -在函数作用域中，可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量
        -当函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接用，没有则向上一级作用域中寻找
    3、变量的声明提前
    使用var关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值)，
        如果声明变量时不使用var关键字，则变量不会被提前声明
    函数的声明提前
        使用函数声明形式创建的函数，它会在所有代码执行前就被创建，所以我们可以在函数声明前就调用函数
        使用函数表达式创建的函数，不会被提前创建

10、this
    解析器在调用函数每次都会向函数内部传递进一个隐含的参数
      这个隐含的参数就是this，this指向的是一个对象
      这个对象我们称为函数执行的上下文对象
    根据函数的调用方式的不同，this会指向不同的对象
        1.以函数的形式调用，this永远都是window
        2.以方法的形式调用，this是调用方法的对象
        3.以构造函数使用，this是新创建的对象
        4.以call和apply调用时，this是指定的对象
    
11、构造函数
    构造函数使用new调用
    构造函数的执行流程：
    1、立即创建一个新的对象
    2、将新建的对象设置为函数中的this
    3、逐行执行函数中的代码
    4、将新建的对象作为返回值返回
      使用同一个构造函数创建的对象，我们称为一类实体，也将一个构造函数称为一个类,
        我们将通过一个构造函数创建的对象称为是该类的实例
    使用instanceof可以检查一个对象是否是一个类的实例
      语法：对象 instanceof 构造函数
       如果是，返回true,否则返回false
    所有对象都是Object的后代，任何对象和Object做instanceof检查时都会返回true
    示例：
    function Person(){
    }
    var per = new Person();
    
12、原型对象
    我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
          这个属性对应着一个对象，这个对象就是我们所谓的原型对象
    如果函数作为普通函数调用prototype没有任何作用
    当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性,
          指向该构造函数的原型对象，我们可以通过__proto__来访问该属性
    原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象
          我们可以将对象中共有的内容，统一设置到原型对象中
    当我们访问对象的一个属性或方法时，他会先在对象自身中寻找，如果有则直接使用
    如果没有则会去原型对象中寻找，如果找到则直接使用
    
    使用in检查对象中是否含有某个属性时，如果对象中没有但原型中有，也会返回true
    可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性
    使用该方法只有当对象自身中含有属性时，才会返回true
    
    原型对象也是对象，所以它也有原型，
    当使用一个对象的属性或方法时，会先在自身中寻找，然后再原型中寻找，然后在原型中的原型中寻找，直到找到Object对象的原型
    Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined
    
13、toString
    当我们直接在页面打印一个对象时，实际上是输出对象的toString方法的返回值
    如果我们希望在输出对象时不输出[object Object],可以为对象添加一个toString方法
    
14、数组
    数组使用数字来作为索引操作元素
    索引：
    从0开始的整数就是索引
    创建数组对象：
      var a=new Array();
    向数组中添加元素：
      语法：数组[索引] = 值;
    读取数组中的元素：
      语法：数组[索引];
    获取数组的长度(元素个数)
      语法：数组.length;
    对于不连续的数组，会返回最大的索引+1
    向数组的最后一个位置添加元素：
      语法：数组[数组.length]=值;
    数组字面量：
      语法：[]
    示例：var sb=[1,2,3,4,5,6,7,8,9];
    
15、数组的方法
    ①push()
      该方法可以向数组末尾添加一个或多个元素，并返回数组的新长度
    示例：
    var a=[1,2,3];
    var result=a.push(4,5,6);
    result==6;
    ②pop
      该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回
    ③unshift
      向数组开头添加一个或多个元素，并返回新的数组长度
    ④shift
      删除数组的第一个元素，并将被删除的元素作为返回值返回
    ⑤slice
      可以用来从数组中提出指定元素
      该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回
    参数：
      1.截取开始位置的索引，包含开始索引
      2.截取结束位置的索引，不包含结束索引
    ⑥splice
      可以用来删除数组中的指定元素
      使用splice会影响到原数组，并将被删除元素作为返回值返回
      参数：
        第一个，表示开始位置的索引
        第二个，表示删除的数量
        第三个及以后，可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
    ⑦concat
      可以链接两个或多个数组，并将新的数组返回
      该方法不会对原数组产生影响
    ⑧join
      该方法可以将一个数组转换为字符串
      该方法不会对原数组产生影响
      在join中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
    ⑨reverse
      该方法用来反转数组
      该方法会直接修改原数组
    ⑩sort
      可以用来对数组中的元素进行排序，会影响原数组，默认按照Unicode编码进行排序
      也可以自己指定排序的规则，在sort中指定一个回调函数，来指定排序规则，回调函数中需要定义两个形参
    









    升序排列：return a-b
    降序排列：return b-a
    11.filter()
      可以用来修改数组
      参数：
          回调函数，第一个实参就是数组内部的所有元素，数组内有几个元素函数就执行几次，
                若返回值是false，则删除该元素，若返回值是true，则保留该元素
                返回修改后的数组
    12.every() some()
      与forEach类似，需要一个回调函数作为参数
      every()
        若回调函数返回false,则停止执行，函数整体返回值为false
        若回调函数返回true,则继续执行，直到判断完所有元素，若所有回调函数时返回值都是true，则整体返回true
      some()
        若回调函数返回true,则停止执行，函数整体返回值为true，若所有回调函数返回值都为false，函数整体才返回false
    13.find()
        可以查找数组中的元素
        参数：
          回调函数，有几个元素就会执行几次，会传入一个参数，是当前正在遍历的元素
          若回调函数的返回值是true，则停止查找
    14.includes()
        可以用于查找数组中的元素
        参数：需要查找的元素
         如果有，则返回true，没有返回false
    15.map()
        用于创建新的数组
        参数：与forEach相同的回调函数
        回调函数的返回值就是这个函数的返回值数组的值
    16.reduce()
        参数：
           ①回调函数
           ②回调函数中第一个参数的初始值
        如果不传第二个参数，那么回调函数中第一个参数就是数组中的第一个元素
        回调函数中的参数：
           1.一个参数
           2.正在遍历的元素
           3.索引
           4.数组
        回调函数每次执行的返回值就是第一个参数的值
    
16、数组的遍历
    所谓数组的遍历，就是把数组中所有的元素都取出来
    for(var i=0;i<arr.length;i++){
    alert(arr[i])
    }  
    
    forEach()方法需要一个函数作为参数
    像这种函数，由我们创建不由我们调用的，我们称为回调函数
    数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素
    以实参传递进来
     第一个实参：正在遍历的元素
     第二个：正在遍历元素的索引
     第三个：正在进行遍历的数组

17、函数补充
    call()、apply()和bind()
      当对函数调用call()和apply()都会调用函数执行,而bind()并不会调用函数
      在调用call()、apply()和bind可以将一个对象指定为第一个参数
      此时这个对象将会成为函数执行时的this
    call方法可以将实参在对象后一次传递
    apply方法需要将实参封装到数组中统一传递
    bind方法只会改变函数的this而不会执行函数
    
    arguments
      argument是一个类数组对象,它也可以通过索引操作数据，也可以获取长度
      调用函数时，我们传递的实参都会在arguments中保存
      它里面有一个属性叫做callee
      这个属性里面对于这一个函数对象，就是当前正在执行的函数对象
示例：
    function a(){};
    a.call(123,"你");
    此时
    a.argument=={
        0:123,
        1:'你'
    };
     a.argument.callee==a;
    
18、Date对象
    创建一个Date对象
    var a = new Date();
    如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间
    需要在构造函数中传递一个表示时间的字符串作为参数
    日期的格式：  月/日/年 时/分/秒
    
    方法：
    ①getDate
      获取当前日期是几日
    ②getDay
      获取当前日期对象是周几，会返回0-6的值，0表示周日
    ③getMonth
      获取当前时间对象的月份，会返回一个0-11的值，0表示一月
    ④getFullYear
      获取当前日期对象的年份
    ⑤getTime
      获取当前日期对象的时间戳
        时间戳：从格林威治标准时间的1970年1月1日0时0分0秒，到当前时间所花的毫秒数
      获取当前的时间戳：
        var time = Date.now();
    
19、Math
     Math和其他对象不同，它不是一个构造函数
     Math中封装了数学计算相关的属性和方法
    
Math中的方法
    ①Math.ceil()
      对数进行向上取整
    ②Math.floor
      对数进行向下取整
    ③Math.round
      对数进行四舍五入取整
    ④Math.random()
      生成一个0-1之间的随机数
      生成x-y之间的随机数：
        Math.round(Math.random()*(y-x)+x);
    ⑤Math.max()
      获取多个值中的最大值
    ⑥Math.min()
      获取多个值中的最小值
    ⑦Math.pow(x,y)
      返回x的y次方
     示例：求3的二次幂
      Math.pow(3,2)
    
20、包装类
    String() Number() Boolean()把基本数据类型转换为Object
    
21、字符串对象的方法
    -在底层字符串是以字符数组的形式保存的
    length属性
      表示字符串的长度
    charAt()
      可以返回字符串中指定位置的字符
      根据索引获取指定的字符
    charCodeAt()
      可以返回字符串中指定位置的字符的Unicode编码
    String.fromCharCode()
      可以根据字符编码获取字符
    concat()
    连接两个或多个字符串，作用和+一样
    indexOf()
      该方法可以检索一个字符串中是否含有指定内容
        如果含有该内容，则会返回第一次出现的索引
        如果没有，则返回-1
      可以指定第二个参数表示开始查找的位置
    lastIndexOf
      该方法可以从后往前检索字符串
    slice
      可以用来从字符串中提出指定元素
      该方法不会改变原字符串，而是将截取到的元素封装到一个新字符串中返回
    参数：
      1.截取开始位置的索引，包含开始索引
      2.截取结束位置的索引，不包含结束索引
    substring
      -可以用来截取一个字符串，与slice()类似
      -不同的是这个方法不能接收负值作为参数
         如果传递了负值作为参数，则默认使用0
      -而且他会自动调整参数的位置，如果第二个参数小于第一个，则交换位置
    substr()
      -用来截取字符串
      -参数：
           1.截取开始位置的索引
           2.截取的长度
    split()
      -可以将一个字符串拆分为一个数组
      -参数：
           -需要一个字符串作为参数，将会根据该字符串拆分字符串
           -如果传递一个空串，则会将每个字符都拆分
           -可以传递一个正则表达式作为参数，这样会根据正则表达式进行拆分，这个方法即使不加全局匹配，也会全部拆分
    示例：
      var str = "1,2,3,4,5,6";
      var result = str.split(",");
      result的结果为[1,2,3,4,5,6];
    toUpperCase()
      -将一个字符串转换为大写并返回
    toLowerCase()
      -将一个字符串转换为小写并返回
    search()
      -可以搜索字符串中是否含有指定内容
      -如果搜索到则会返回第一次出现的索引，如果没有则返回-1
      -它可以接受一个正则表达式作为参数，然后回根据正则表达式去检索字符串
      -search()也会查找第一个，但是不能全局
    match()
      -可以根据正则表达式从一个字符串中提取符合条件的内容
      -默认match()只会找到第一个符合要求的内容，找到以后就停止检索
           我们可以将正则表达式设置为全局匹配模式，这样就会匹配到所有的内容
           可以为一个正则表达式设置多个匹配模式，且顺序无所谓
      -match()会将结果封装到数组中返回，既是只查询到一个结果
    replace()
      -可以将字符串中的指定内容替换为新的内容
      -参数：
           1.被替换的内容，可以接受正则表达式作为参数
           2.新的内容
      -默认只会替换第一个
    trim
      清除字符串间的空白字符
    
22、正则表达式
    ①正则表达式用于定义一些字符串的规则
        计算机可以根据正则表达式来检查一个字符串是否符合规则，
        或者将字符串中符合规则的内容提取出来
    创建正则表达式对象
        语法：var 变量 = new RegExp("正则表达式","匹配模式");
              使用typeof检查会返回object
    正则表达式的方法：test()，可以用来检查字符串是否符合正则表达式的规则，如符合则返回true，否则返回false
    示例：
        var a = new RegExp("a");
        a.test("abc");//会返回true
        这个正则表达式可以检查字符串中是否有a
    在构造函数中可以传递一个匹配模式作为第二个参数
    可选值：
        i  忽略大小写
        g  全局匹配模式
    
    ②正则语法
    使用字面量来创建正则表达式
        语法：var 变量 = /正则表达式/匹配模式
        -使用字面量创建更加简单
        -使用构造函数更加灵活
    示例：
        var reg = /a/i;
        //这个正则表达式与上面的效果相同
    使用|表示或者的意思
    示例：
        var reg = /a|b/;
        reg.text("ac");
        reg.text("bc");
        //这两个都会返回true
    []里的内容也是或的关系
        [ab]  表示a|b
        [a-z] 表示任意的小写字母
        [A-Z] 表示任意的大写字母
        [A-z] 表示任意的字母
        [0-9] 表示任意数字
        [^ ]  表示查找除了[]里面的内容
    量词
      -通过量词可以设置一个内容出现的次数
      -量词只对它前边的一个内容起作用
      -{n}   表示正好出现n次
      -{m,n} 表示正好出现m-n次
      -{n,}  表示正好出现n次以上
      - +    表示至少一个，相当于{1,}  示例：/+a/
      - *    表示0个或多个，相当于{0,}
      - ?    表示0个或一个，相当于{0,1}
      - ?    表示非贪婪模式，不会继续匹配接下来的字符
      - ^    表示开头    示例：/^a/
      - $    表示结尾    示例：/a$/
      - ^$   表示字符串必须完全符合正则表达式    示例：/^a$/
    
     ③其他语法
     .表示除换行符以外的任意字符
     ()表示对正则表达式进行分组
     在正则表达式中使用\作为转义字符
       \.表示.
     注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中的转义字符，
           如果需要使用\则需要使用\\代替
     \w    表示任意字母、数字、_
     \W    表示除了字母、数字、_
     \d    表示任意数字
     \D    表示除了数字
     \s    表示空格
     \S    表示除了空格
     \b    表示单词边界(单词前面或后面的空格)  示例：/\bChild\b/
     \B    表示除了单词边界
    
十、DOM
    浏览器已经为我们提供 文档节点 对象，这个对象是window属性
     可以在页面中直接使用，文档节点代表的是整个网页
    
1、事件
    事件，就是用户和浏览器之间的交互行为
    我们可以在时间对应的属性中设置一些JS代码，
        这样当事件触发时，这些代码将会执行
    这种写法叫做结构与行为耦合，不推荐使用
    可以为按钮的对应事件绑定处理函数的形式来响应事件 
     这样当事件被触发时，其对应的函数将会被调用
    
2、文档的加载
    浏览器在加载一个页面时，是按照自上向下的顺序加载的
      读取到一行就运行一行，如果将script写到页面的上边
      在代码执行时，页面还没有加载，会导致无法获取到DOM对象
    onload事件会在整个页面加载完成后才会触发
    为window绑定一个onload事件
            该事件对应的响应函数将会在页面加载完毕之后进行
            这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了
    
3、DOM查询
    ①获取元素节点
    innerHTML用于元素内部的HTML代码
        对于自结束标签没有意义
    如果需要读取元素节点属性
        直接使用元素.属性名
        注意：class属性不能采用这种方式
              读取class属性时需要使用元素.className
    
    ②获取元素节点的子节点
    1.getElementByTagName()
        方法,查找当前节点下指定标签名的子节点
    2.childNotes
        属性,返回当前节点下的所有子节点
            这个属性会获取包括文本节点包括在内的所有节点
            根据DOM标准，标签中的空白也会当成文本节点
            注意：在IE8及以下浏览器中，不会将空白文本当做子节点
       children这个属性可以获取当前这个元素的子元素
    3.firstChild
        属性,返回当前节点下的第一个子节点
       firstElementChild获取当前元素的第一个子元素
    4.lastChild
        属性,返回当前节点下的最后一个子节点
       lastElementChild获取当前元素的最后一个子元素
    
    ③获取父节点和兄弟节点
    1.parentNode
        属性，表示当前节点的父节点
    2.previousSibling
        属性，表示当前节点的前一个兄弟节点
      previousElementSibling  获取前一个兄弟元素
    3.nextSibling
        属性，表示当前节点的后一个兄弟节点
    innerText  该属性可以获取到元素内部的文本内容
    
    ④DOM查询的剩余部分
    1.document.body
        在document中，有一个属性body,它保存的就是body的引用
    2.document.documentElement
        它保存的就是HTML根标签
    3.document.all
        它代表页面中所有的元素,相当于document.getElementsByTagName("*");
    4.document.getElementsByClassName()
        根据元素的Class属性查询一组元素节点对象，但是不支持IE8及以下的浏览器
    5.document.querySelector()
        -需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象
        -使用该方法总会返回唯一的元素，如果满足条件的元素有多个，那么它只会返回第一个
        -支持IE8以上的浏览器
        示例：document.querySelector("div div");//可以找到一个div下的div对象
    6.document.querySelectorAll()
        -该方法与用法document.querySelector类似，但是它会将所有符合条件的元素封装到一个数组中返回
        -即使符合条件的元素只有一个，它也会返回数组
    
4、DOM增删改
    ①document.createElement()
        可以用于创建一个元素节点对象
        它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，
        并将创建好的对象作为返回值返回
    示例：var li = document.createElement("li");
    ②document.createTextNode()
        可以用来创建一个文本节点对象
        需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回
    示例：var text = document.createTextNode("广州");
    ③appendChild()
        -向一个父节点中添加一个新的子节点
        -用法：父元素.appendChild(子节点);
    示例：li.appendChild(text);
    ④insertBefore()
        -可以在指定的子节点前插入新的子节点
        -语法：父节点.insertBefore(新节点,旧节点);
    ⑤replaceChild()
        -可以使用指定的子节点替换已有的子节点
        -语法：父节点.replaceChild(新节点,旧节点);
    ⑥removeChild()
        -可以删除一个子节点
        -语法：父节点.removeChild(子节点);
               子节点.parentNode.removeChild(子节点);
    使用innerHTML也可以完成DOM增删改的相关操作
    一般我们会两种方式结合使用
    
5、DOM操作样式
    ①通过JS来修改元素的样式:
     语法：元素.style.样式名 = 样式值
    注意：如果CSS的样式名中含有-
           这种名称在JS中是不合法的，比如：background-color
           需要将这种样式名修改为驼峰命名法，
           去掉-，然后将-后的字母大写
    我们通过style属性设置的样式都是内联样式，
     而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示
    但是如果在样式中写了!important，则此时样式会有最高的优先级
     既是通过JS也不能覆盖该样式，此时将会导致JS修改样式失效
     所以尽量不要为样式添加!important
    
    ②读取元素的样式
     语法：元素.style.样式名
    
    通过style属性读取和设置的都是内联样式
     无法读取样式表中的样式

    ③获取元素当前显示的样式
     语法：元素.currentStyle.样式名
    它可以用来当前元素正在显示的样式
     如果当前元素没有设置该样式，则获取它的默认值
    currentStyle只有IE浏览器支持，其他的浏览器都不支持
    在其他浏览器中可以使用
            getComputedStyle()这个方法来获取元素当前的样式
            这个方法是window的方法，可以直接使用
    需要两个参数
           第一个：要获取样式的元素
           第二个：可以传递一个伪元素，一般都传null
    该方法会返回一个对象，对象中封装了当前元素对应的样式
     可以通过对象.样式名来读取样式
     如果获取的样式没有设置，则会获取到真实的值，而不是默认值
    但是该方法不支持IE8及以下的浏览器
    通过currentStyle和getComputedStyle()读取到的样式都是只读的，
     不能修改，如果要修改，必须通过style属性
    
    解决方法：
        定义一个函数，用来获取指定元素的当前的样式
        参数：
             obj  要获取样式的元素的
             name 要获取的样式名
    function getStyle(obj,name){
        if(window.getComputedStyle){
            //正常浏览器的方式,具有getComputedStyle()方法
            return getComputedStyle(obj,null)[name];
        }else{
            //IE8的方式，没有getComputedStyle()方法
            return obj.currentStyle[name];
        }
    }
    
    ④其他样式相关的属性
    clientWidth
    clientHeight
     - 这两个属性可以获取元素的可见宽度和高度
     - 这些属性都是不带px的，返回都是一个数字，可以直接进行计算
     - 获取元素宽度和高度，包括内容区和内边距
     - 这些属性都是只读的，不能修改
    
    offsetWidth
    offsetHeight
     - 获取元素的整个的宽度和高度，包括内容区、内边距和边框
    
    offsetParent
     - 可以用来获取当前元素的定位父元素
     - 它会获取到离当前元素最近的开启了定位的祖先元素
            如果所有的祖先元素都没有开启定位，则返回body
    
    offsetLeft
     - 当前元素相对于其定位元素的水平偏移量
    offsetTop
     - 当前元素相对于其定位元素的垂直偏移量
    
    scrollWidth
    scrollHeight
     - 可以获取元素整个滚动区域的宽度和高度
    
    scrollLeft
     - 可以获取水平滚动条滚动的距离
    scrollTop
     - 可以获取垂直滚动条滚动的距离
    
    当满足scrollHeight - scrollTop == clientHeight
    说明垂直滚动条滚动到底了
    当满足scrollWidth - scrollLeft == clientHeight
    说明水平滚动条滚动到底了
    
6、事件对象
    -当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数
        在事件对象中封装了当前事件相关的一切信息
    在IE8中，响应函数被触发时，浏览器不会传递事件对象，
     在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的
    解决方法：event = event || window.event;
    
    clientX可以获取鼠标指针的水平坐标
    clientY可以获取鼠标指针的垂直坐标
        这两个用于获取鼠标在当前的可视窗口的坐标
    
    pageX和pageY可以获取鼠标相对于当前页面的坐标
        但是这两个属性在IE8中不支持，如果需要兼容IE8，则不要使用
    解决方法：
        chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取
        火狐等浏览器认为滚动条是html的
        scrollTop = document.body.scrollTop || document.documentElement.scrollTop
        top = clientY + scrollTop + "px";
        scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft
        left = clientX + scrollLeft + "px";
    
7、事件的冒泡(Bubble)
    -所谓冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发
    -在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡
    可以将事件对象的cancelBubble设置为true，即可取消冒泡
    
    应用：
    我们希望只绑定一次事件，即可应用到多个元素上，既是元素是后添加的
    我们可以尝试将其绑定给元素的共同的祖先元素
    事件的委派
      -指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素
          从而通过祖先元素的响应函数来处理事件
      -事件的委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能
    target
     - event中的target表示的是触发事件的对象
    
8、事件的绑定
    使用 对象.事件 = 函数 的形式绑定响应函数，
     它只能同时为一个元素的一个事件绑定一个响应函数，
     不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的
    
    addEventListener()
     - 通过这个方法也可以为元素绑定响应函数
     - 参数：
           1.事件的字符串，不要on
           2.回调函数，当事件触发时，该函数会被调用
           3.是否在捕获阶段触发事件，需要一个布尔值，一般传false
    使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，
     这样当事件被触发时，响应函数将会按照函数的绑定顺序执行
    这个方法不支持IE8及以下的浏览器
    
    attachEvent()
     - 在IE8中可以使用attachEvent()来绑定事件
     - 参数：
           1.事件的字符串，要on
           2.回调函数
     - 这个方法也可以同时为一个事件绑定多个处理函数，
          不同的是它是先绑定后执行，执行顺序与addEventListener()相反
      但是其他的浏览器不支持
    
    addEventListener()中的this，是绑定的对象
    attachEvent()中的this,是window
     需要统一两个方法中的this
    this是谁由调用方式决定
    
    解决方法：
    定义一个函数，用来为指定元素绑定函数
        参数：
            obj 要绑定事件的对象
            eventStr 事件的字符串(不要on)
            callback  回调函数
    function bind(obj,eventStr,callback){
    if(obj.addEventListener){
        //大部分浏览器兼容的方式
        obj.addEventListener(eventStr,callback,false);
    }else{
        //IE8及以下
        obj.addEventListener("on"+eventStr,function(){
            //在匿名函数中调用回调函数
            callback.call(obj);
        });
    }
    }
    
9、事件的传播
    - 关于事件的传播网景公司和微软公司有不同的理解
    - 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，
         然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行
    - 网景公司认为事件应该是由外向内传播，也就是当事件触发时，应该先触发当前元素的最外层的祖先元素的事件
         然后再向内传播给后代元素
    - W3C综合了两个公司的方案，将事件传播分成了三个阶段
         1.捕获阶段
               - 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
         2.目标阶段
               - 事件捕获到目标元素，捕获结束，开始在目标元素上触发事件
         3.冒泡阶段
               - 事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件
         - 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true
              一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false
    - IE8及以下的浏览器中没有捕获阶段
    - 当调用一个元素的setCapture()方法后，这个元素就会把下一次所有的鼠标按下相关的事件捕获到自身上
    setCapture()
     - 只有IE支持，但是在火狐中调用时不会报错，
          而如果使用chrome调用，会报错
    
10、其他的事件
    ①滚轮的事件
    onmousewheel 
     - 鼠标滚轮滚动的事件，会在滚轮滚动时触发，
        但是火狐不支持该属性
     - 在火狐中需要使用DOMMouseScroll来绑定滚动事件
        注意：该事件需要通过addEventListener()函数来绑定

    wheelDelta 可以获取鼠标的滚动方向
      向上滚返回120，向下滚返回-120
    wheelDelta这个值我们不看大小，只看正负
    wheelDelta这个属性火狐中不支持

    在火狐中使用detail来获取滚动方向
      向上滚返回-3，向下滚返回3
    使用addEventListener()方法绑定的响应函数，取消默认行为不能使用return false;
      需要使用event来取消默认行为
      使用event.preventDefault()来取消默认行为
    
    ②键盘事件
     onkeydown
          - 按键被按下
          - 对于onkeydown来说，如果一直按着某个按键不松手，则事件会一直触发
          - 当onkeydown连续触发时，第一次和第二次之间间隔会长一点，其他的会非常的快
               这种设计是为了防止误操作的发生
     onkeyup
          - 按键被松开
    
    键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
    
    可以通过keyCode来获取按键的编码
     通过keyCode可以判断那个按键被按下
    除了keyCode，事件对象中还提供了几个属性
     altKey
     ctrlKey
     shiftKey
          - 这几个属性用来判断alt ctrl shift是否被按下
                 如果按下则返回true,否则返回false
    在文本框中输入内容属于onkeydown的默认行为，如果取消了默认行为，则内容不会出现在文本框中
    
十一、BOM
    - 浏览器对象模型
    - BOM可以使我们通过JS来操作浏览器
    - 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
    - BOM对象
         Window
              - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象
         Navigator
              - 代表的是当前浏览器的信息，通过该对象可以用来识别不同的浏览器
         Location
              - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
         History
              - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
                   由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
                   而且该操作只在当次访问时有效
         Screen
              - 代表用户的屏幕信息，通过该对象可以获取到用户的显示器的相关的信息
    
         这些BOM对象在浏览器中都是作为window对象的属性保存的,
               可以通过window对象来使用，也可以直接使用
    
1、Navigator
    - 代表的是当前浏览器的信息，通过该对象可以用来识别不同的浏览器
    - 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了
    - 一般我们只会使用userAgent来判断浏览器的信息，
         userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，
         不同的浏览器会有不同的userAgent
    如果通过userAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
    比如：ActiveXObject
    判断浏览器：
    var ua = navigator.userAgent;
    if(/firefox/i.test(ua)){
        //你是火狐
    }else if(/chrome/i.test(ua)){
        //你是chrome
    }else if("ActiveXObject" in window){
        //你是IE
    }
    
2、History
     - 可以用来操作浏览器向前或向后翻页
    
    length
     - 属性，可以获取到当次访问的链接数量
    back()
     - 方法，可以用来回退到上一个页面，作用和浏览器的回退按钮一样
    forward()
     - 方法，可以跳转到下一个页面，作用和浏览器的前进按钮一样
    go()
     - 方法，可以用来跳转到指定的页面
     - 它需要一个整数作为参数
          1:表示向前跳转一个页面
         -1:表示向后跳转一个页面
    
3、Location
    - 该对象中封装了浏览器的地址栏的信息
    如果直接打印location，则可以获取到地址栏的信息(当前页面的完整路径)
    如果直接将location属性修改为一个完整的路径或相对路径
     则我们页面会自动跳转到该路径，并且会生成相应的历史记录
    
    assign()
     - 用来跳转到其他的页面，作用和直接修改location一样
    reload()
     - 用于重新加载当前页面，作用和刷新按钮一样
     - 如果在方法中传递一个true作为参数，则会强制清空缓存刷新页面
    replace()
     - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
          不会生成历史记录，不能使用回退按钮回退
    
十二、定时器
    JS的程序的执行速度是非常非常快的
     如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用
    
    setInterval()
     - 定时调用
     - 可以将一个函数，每隔一段时间执行一次
     - 参数：
          1.回调函数，该函数会每隔一段时间被调用一次
          2.每次调用间隔的时间，单位是毫秒
     - 返回值：
          返回一个Number类型的数据
          这个数字用来作为定时器的唯一标识
    示例：var timer = setInterval(function(){alert("ych是伞兵")},1000);
    
    clearInterval()
     - 可以用来关闭一个定时器
     - 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
     - 可以接收任意参数
         如果参数是一个有效的定时器的标识，则停止对应的定时器
         如果参数不是一个有效的标识，则什么也不做
    示例：clearInterval(timer);
    
    setTimeout()
     - 延时调用
     - 延时调用一个函数不马上执行，而是隔一段时间以后再执行，而且只会执行一次
     - 延时调用和定时调用的区别：定时调用会执行多次，而延时调用只会执行一次
     - 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己的需要去选择
    
    clearTimeout()
     - 关闭一个延时调用
    
十三、剩余基础内容
1、类的操作
    通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面
     这样的执行性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便
    我们可以通过修改元素的class属性来间接地修改样式
    这样一来，我们只需要修改一次，即可同时修改多个样式
     浏览器只需要重新渲染页面一次，性能比较好，
     并且这种方式，可是使表现和行为进一步地分离
     
    定义一个函数，用来向一个元素中添加指定的class属性值
    参数：obj:要添加class属性的元素 cn:要添加的class值
    function addClass(obj,cn){
        if(!hasClass(obj,cn)){
            obj.className += " " + cn;
        }
    }
    判断一个元素中是否含有指定的class属性值
     如果有返回true，否则返回false
    function hasClass(obj,cn){
        var reg = new RegExp("\\b"+cn+"\\b")
        return reg.test(obj.className);
    }
    删除一个元素中的class
    function removeClass(obj,cn){
        var reg = new RegExp("\\b"+cn+"\\b");
        obj.className = obj.ClassName.replace(reg,"");
    }
    切换一个类，如果元素中有该类，则删除，如果没有，则添加
    function toggleClass(obj,cn){
        if(hasClass(obj,cn)){
            removeClass(obj,cn);
        }else{
            addClass(obj,cn);
        }
    }
    
2、JSON
    - JS中的对象只有JS自己认识，其他的语言都不认识
    - JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别
         并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
    - JSON
         - Javascript Object Notation
         - JSON和JS的对象格式一样，只不过JSON字符串中属性名必须加双引号
              其他的和JS语法一致
         JSON分类：
               1.对象 {}
               2.数组 []
         JSON中允许的值：
               1.字符串
               2.数值
               3.布尔值
               4.null
               5.对象
               6.数组
    
    将JSON字符串转换为JS中的对象
     在JS中，为我们提供提供了一个工具类，就叫JSON
     这个对象可也帮助我们将一个JSON转换为一个JS对象，也可以将一个JS对象转换为一个JSON
    
    JSON --> JS对象
      JSON.parse()
         - 可以将JSON字符串转换为JS对象
         - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回
    JS对象 --> JSON
      JSON.stringify()
           - 可以将一个JS对象转换为JSON字符串
           - 需要一个JS对象作为参数，会返回一个JSON字符串
    
    JSON这个对象在IE7及以下的浏览器不支持，所以在这些浏览器中调用时会报错
    
    eval()
     - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回
     - 如果使用evel()执行的字符串中含有{}，它会将{}当成是代码块
          如果不希望将其当成代码块解析，则需要在字符串前后各加一个()
     - evel()这个函数功能很强大，可以直接执行一个字符串中的代码，
          但是开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患
    
    
    
    
    
    
    
高级内容
    
十四、其他补充
    ②try...catch...finally语句
    try语句中可以检查代码是否发生了错误，
      如果错误，这会在catch语句中返回错误信息
    finally语句无论try语句中是否执行，都会执行
      在catch中必须要传入一个参数，作为Error对象，可以使用err.message来获取错误信息
    
    throw语句可以自定义错误时抛出的信息，可以自定义错误信息
    示例：
    try{
        allert();
        if(window.allert == undefined)throw "此函数未定义"
    }catch(err){
        alert(err.message);
    }finally{
        alert("结束")
    }
    Error对象
    属性：
    name  设置或返回错误名
    message  设置或返回错误信息
    
    ③debugger
    可以在一个函数中执行，函数将会在此处停止执行
    示例：
    function a(){
        alert()
        debugger;
        console.log()
        //函数不会执行console.log,但alert()会执行
    }
    ⑥严格模式
    "use strict"的作用是指示JavaScript的代码应该以严格模式执行
    1、不能使用未声明的对象  示例：a = 1//报错
    2、删除变量或对象时不被允许的
    3、删除函数不被允许
    3、重复参数名不被允许
    4、八进制数值不被允许
    5、转义字符不被允许
    6、写入只读属性不被允许
    7、写入只能获取的属性不被允许
    8、删除不可删除属性
    9、with语句不被允许
    10、eval()不能创建变量
    11、this从window变成undefined
    
十五、HTML API
    ①全屏
      HTML5规范允许用户自定义网页上任意元素全屏显示
        1、开启全屏    Node.requestFullScreen()
        2、关闭全屏    Node.cancelFullScreen()
      但是存在兼容性问题，所以不同浏览器需要增加不同的前缀
        webkit内核浏览器：webkitRequestFullScreen、webkitCancelFullScreen，如chrome浏览器
        Gecko内核浏览器：mozRequestFullScreen、mozCancelFullScreen，如火狐浏览器
      加的前缀种类：webkit、moz、o、ms
      解决兼容问题的方法：
      // 开启全屏
      function fullScreen(obj){
          if(obj.requestFullScreen){
              obj.requestFullScreen();
          }else if(obj.webkitRequestFullScreen){
              obj.webkitRequestFullScreen();
          }else if(obj.mozRequestFullScreen){
              obj.mozRequestFullScreen();
          }else if(obj.oRequestFullScreen){
              obj.oRequestFullScreen();
          }else if(obj.msRequestFullscreen){//注意IE的s是小写
              obj.msRequestFullscreen();
          }
      }
      //取消全屏，与元素没有关系，是取消document的全屏
      document.webkitCancelFullScreen();
      
     是否全屏显示
      通过document.fullscreen 来查询
      
    ②文件读取
      我们想把上传的文件的内容显示到页面中或上传完毕的图片显示缩略图
        1、上传我们的文件 通过<input type="file">来上传文件
        2、选择我们的图片进行读取 fileReader
        3、把读取的内容显示到页面中
      onchange事件  当元素发射改变时触发
    
      files对象
        在input file对象中，有一个files属性
        该属性是一个类数组对象，封存了上传的所有文件
    
      fileReader对象
        可以读取本地文件内容
        使用方法：
            var a = new FileReader();//可以创建一个FileReader对象
        方法：
          readAsText  读取文件的文本内容
          readAsDataURL  读取一个以data:开头的URL字符串，可以实现图片预览
          readAsBinaryString  以二进制来读取文件
          readAsArrayBuffer
        属性：
          result  保存读取的结果
        事件：
          onload  读取完毕后调用
    
    ③document.execCommand()
        三个参数：
           1.执行的命令
           2.是否展示用户界面
           3.一些命令需要的额外参数
    命令种类：
      copy:将内容复制到剪切板
      backColor:修改文档背景颜色
      bold:加粗字体
      createLink:创建一个链接锚，需要第三个参数传入href属性
      cut:剪切
      delete:删除
      fontSize:设置字体大小
      forwardDelete:删除光标所在的字符
      indent:插入缩进
      insertImage:插入图片,第三个参数为src属性
      paste:粘贴剪切板内容
      redo:重做被撤销操作
      selectAll:选中全部内容
      undo:撤销最近执行的命令
      
      
十六、canvas
    1、<canvas>
      可以创建一块画布，只是一个图片容器，自身不具备绘画的能力，需要JavaScript来实现
    画一条直线的步骤：
      ①找到canvas元素
        示例：var a = document.querySelector("canvas");
      ②获取画布的上下文(Context对象)
        getContext("2d")是HTML5内建对象，拥有很多绘制路径、文字、圆形、字符以及图像的方法,是固定不变的
        示例：var atx = a.getContext("2d");
      ③开始一条路径
        atx.beginPath()可以开启一条路径
      ④确定开始点
        atx.moveTo(x,y)
          x和y表示起始点的坐标
      ⑤确定结束点
        atx.lineTo(x,y)
          x和y表示结束点的坐标,可以多次使用继续画直线，下一次使用时的开始坐标就是上一次调用时的结束坐标
          示例：
            ctx.moveTo(200,200);
            ctx.lineTo(100,100);
            ctx.lineTo(200,200);
            //可以连画200,200到100,100到200,200的一个三角形
      ⑥着色
        atx.stroke();可以进行上色
      ⑤结束路径
        atx.closePath();用于结束路径
    属性：
      lineCap 设置或返回线条开始和结束点的样式 可选值：butt 尖锐角 round 圆角
      lineJoin 设置或返回线条拐角处的样式 可选值：miter 尖角 round 圆角
      lineWidth  设置线宽，需要在着色之前设置
      miterLimit 设置拐角的角度裁剪，会在拐角处裁剪对像素的角
      fillStyle 设置或返回用于填充绘画的颜色、渐变或模式
      strokeStyle 设置或返回笔触的颜色、渐变或模式，需要在着色之前设置
      strokeColor 设置或返回用于阴影的颜色
      strokeBlur 设置或返回阴影的模糊级别
      shadowOffsetX 设置或返回阴影与形状的水平距离
      shadowOffsetY 设置或返回阴影与形状的垂直距离
      font 设置字体的相关样式
      textAlign 设置文字的对齐方式  
        可选值：
            start 文字末尾在坐标处
            end  文字首部在坐标处
            center 文字中间在坐标处
            left  与start相同
            right  与end相同
       textBaseline 设置文字垂直布局
         可选值：
            top  文字顶部与基线重合
            bottom  默认值，文字底部与基线重合
            middle  文字中间与基线重合
           
      方法：
      rect(x,y,width,height)
        用于绘制矩形
        参数：
           ①左上角x坐标
           ②左上角y坐标
           ③矩形的宽
           ④矩形的高
      fillRect(x,y,w,h)
        绘制实心矩形
      strokeRect(x,y,w,h)
        绘制空心矩形
      clearRect(x,y,w,h)
        清除画布的一定范围
      arc(x,y,radius,startAngle,endAngle,counterclockwise)
        使用一个中心点和半径，在一个画布的当前子路径添加一条弧
        参数：
          ①圆心x坐标
          ②圆心y坐标
          ③圆的半径
          ④沿着圆指定的开始点的角度，这个角度是弧制度，用弧度来衡量
          ⑤结束点的角度
          ⑥弧沿着圆周逆时针(true)还是顺时针(false)方向遍历
      fillText(text,x,y,maxWidth)
        用于绘制文字
        参数：
          ①绘制的文字
          ②文字的x坐标
          ③y坐标
          ④文字占用的最大宽度
      strokeText()
        绘制空心文字
      creatLinearGradient(x0,y0,x1,y1)
        创建线性渐变对象
        参数：
        ①渐变开始x坐标
        ②渐变开始y坐标
        ③渐变结束x坐标
        ④渐变结束y坐标
        渐变对象方法：
            addColorStop(start,color)
            参数：
              ①渐变开始的百分比
              ②渐变颜色
        设置fillStyle或strokeStyle来应用渐变
        示例：ctx.fillStyle = gradient
      fill()
        在绘制完毕后对图形进行填充
      stroke()
        在绘制完毕后对路径进行描边，显示在页面中
    
十七、DOM、BOM拓展
    1、属性操作
      1.获取元素属性值
        ①元素.属性
            只能获取内置属性(元素自带属性值)
        ②元素.getAttribute(属性)
            能获取到自定义属性
        ③H5新增方法
            元素.dataset.属性 来获取以data-开头的自定义属性
      2.设置移出自定义属性值
        ①元素.属性 = 新属性;
           只能修改内置属性
        ②元素.setAttribute(属性,值)
            能修改自定义属性
      3.移出元素属性
        removeAttribute(属性)
      自定义属性规范：必须以data-开头
    2、节点操作
      ①复制节点
        通过node.cloneNode()来克隆一个节点
      注意：如果第一个参数为false，则只复制标签，不复制子节点
    3、移除事件
      Element.removeEventListener(事件,移出的函数,是否冒泡)
    4、事件
      阻止默认行为： e.preventDefunct()
      阻止冒泡： e.stopPropagation()
      oncontextmenu  控制如何显示右键菜单
      onselectstart  开始选中文本
      onresize 当窗口大小调整时调用
      ontouchstart 手指触摸到元素触发
      ontouchmove  手指触摸到元素移动触发
      ontouchend  手指上移触发
      animationed  动画执行完毕触发
      事件对象：
        touches  触摸屏幕所有手指的列表
        targetTouches  正在触摸当前元素的手指列表
        changedTouches  手指状态发生改变，从无到有，从有到无
    <meta content="user-scalable=no">可以阻止用户缩放
    5、元素classList属性
      元素.classList属性里面包含了元素的类名
      add()  方法可以增加一个类名
      remove()  方法可以删除一个类名
      toggle()  方法可以切换类
    6、本地存储
      ①window.sessionStorage
        1.生命周期为关闭浏览器窗口
        2.在同一个窗口下数据可以共享
        3.是以名值对的形式存储使用
      sessionStorage.setItem(key,value)  
        可以存储数据
      sessionStorage.getItem(key)
        可以获取数据
      sessionStorage.removeItem(key)
        可以删除数据
      sessionStorage.clear()
        可以清除所有数据
     ②window.localStorage
       1.生命周期永久生效
       2.不同页面也可共享
     方法与sessionStorage一致
    
十八、ES6-11
①ES6
1、let
  -用于声明变量，但是与var有些不同
  -声明特性：
    1.变量不能重复声明
    2.块级作用域，变量只在代码块中有效，代码块外无效
    示例：
    {
      let a = 1;
    }
    console.log(a)//Error:a is not defined
    3.不存在变量提升
    4.不影响作用域链
    示例：
    {
      let a = 1;
      function(){
          //仍然可以读取到a变量
          alert(a);
      }()
    }
    
2、const
  -用于声明常量，即不可修改的量
  -注意事项：
    1.一定要赋初始值
    2.一般常量使用大写(浅规则)
    3.常量的值不能修改
    4.也拥有块级作用域
    5.对于数组和对象的元素修改不算对常量的修改，不会报错
    
3、变量的解构赋值
    ES6允许按照一定模式从数组和对象中提取值，并对变量进行赋值，
       这被称为解构赋值
    1.数组结构
      格式：var [变量1,变量2...] = 数组对象
       可以把数组的元素分别赋值给变量
    2.对象解构
      格式：var {属性名1,属性名2...} = 对象;
        可以将对象中的属性值赋值给每一个变量
      示例：
      var obj = {
        age:11
      }
      var {age} = obj;//变量age的值就是11
    
4、模板字符串
    ES6中引入新的声明字符串的方式：``
    1.声明
      格式：var 变量名 = `内容`
    2.内容中可以直接出现换行符
      示例：`我是
             时时刻刻
             不`
    3.变量拼接
      格式：`${变量}字符串内容`
      示例：
        let a = "我";
        let b = `${a}是爸爸`;
    
5、简化对象写法
    ES6允许在大括号中直接写入变量和函数，作为对象的属性和方法，更加简洁
    示例：
      let a = 123;
      const obj = {
        a,
        b(a.b){
          return a+b;
        },
        name:"爸爸"
      }
    
6、箭头函数
    ES6允许使用「箭头」(=>)来声明函数
    函数声明：
      格式：
        var 函数名 = (形参) => {
            语句...
        }
    声明特性：
      1.this是静态的，this始终指向函数声明时所在的作用域下的this的值,没有自己的this
      2.不能作为构造函数
      3.不能使用arguments变量
      4.箭头函数的简写
          (1) 省略小括号，当形参有且只有形参的时候
          (2) 省略大括号，当代码体只有一条语句的时候，此时return必须省略，而且语句的执行结果就是语句的返回值
        示例：var a = n => n*n
    
7、函数形参初始值
    ES6允许给函数参数赋值初始值
    1.形参初始值,具有默认值的参数，一般位置要靠后
      示例：
      function(a,b=10){
          return a + b;
      }(1);
      //此时函数会返回11
     2.与解构赋值结合
     示例：
    var fun = function({name="爸爸",age,gender}){
        console.log(name);//name为爸爸
        console.log(age);//age是19
        console.log(gender);//gender是男
    }
    fun({
        age:19,
        gender:"男"
    })
    
8、rest参数
    ES6中引入rest参数，用于获取函数的实参，用来代替arguments
    rest参数使用方法
    function(形参,...变量名){
        //用变量名来使用rest参数，rest参数是一个数组，rest参数必须放在参数最后
    }
    
9、扩展运算符
    ...扩展运算符可以将数组转换为由逗号分隔的参数序列
    示例：
    var Arr = [1,2,3,4,5,6]
    function fun(){
      console.log(arguments);
      //此时arguments内会有6个参数，分别是：1,2,3,4,5,6
    }
    fun(...Arr)
    应用场景：
      1.数组的合并
      示例：
        var arr1 = [1,2,3];
        var arr2 = [4,5,6];
        var result = [...arr1,...arr2];
        //此时result===[1,2,3,4,5,6]
      2.数组的克隆
      示例：
        var Arr = [1,2,3];
        var b = [...Arr];//b就是[1,2,3]
      3.将伪数组转换为数组
      示例：
        var divs = document.querySelectorAll("div");
        var divArr = [...divs];
    
10、Symbol
    ES6引入了一种新的数据类型Symbol，表示独一无二的值，它是第七个基本数据类型，是类似于字符串的数据类型
    Symbol特点：
      1.Symbol的值是唯一的，用来解决命名冲突的问题
      2.Symbol的值不能与其他数据进行运算
      3.Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名
    创建Symbol
      格式：var 变量名 = Symbol();
            var 变量名 = Symbol(描述字符串)
            var 变量名 = Symbol.for(描述字符串)
    
11、迭代器
    迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。
    任何数据结构只要部署Iterator接口，就可以完成遍历操作  
    1)ES6创造了一种新的遍历命令for...of循环，迭代器主要供for...of消费
    2)原生具备迭代器接口的数据(可以for...of遍历)：Array Arguments Set Map String TypedArray NodeList
    示例：
    const a = [1,2,3];
    for(let i of a){
        console.log(i);
    }
    3)工作原理
      1.创建一个指针对象，指向当前数据结构的起始位置
      2.第一次调用对象的next方法，指针自动指向数据结构的第一个成员
      3.接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员
      4.每调用一次next方法返回一个包含value和done属性的对象（value就是遍历的数据，done表示是否完成遍历）
    注：要自定义遍历数据时要使用到迭代器
    
    自定义遍历数据示例：
    const obj = {
        a:1,
        b:[
            0,
            1,
            2
        ]
        [Symbol.iterator](){
            let index = 0;//索引变量
            let _this = this;
            return {
                next(){
                    if(index < _this.b.length){
                        return {value:_this.b[index],done:false};
                        index++;
                    }else{
                        return {value:undefined,done:true};
                    }
                }
            };
        }
    }
    //使用for...of遍历对象中的数组b
    for(let i of obj.b){
    
    }
    
12、生成器
    生成器其实就是一个特殊的函数，可以进行异步编程
    yield是函数代码的分割符
    格式：
    function * 函数名(){
        yield "你妈死了";
        yield "你妈死了，too";
    }
    
    调用：
      函数的返回值是一个迭代器对象，所以使用next方法调用函数，所以可以使用for...of遍历
      函数返回值.next()
    
      next中可以传入实参，这个实参将作为上一个yield语句的返回值
      示例：
      function * y(){
          let a = yield 111;
          let b = yield 222;
      }
      y().next();//此时a === 111
      y().next(333);//此时a === 333
    
13、Promise
    Promise是ES6引入的异步编程的解决方案，语法上Promise是一个构造函数
    用来封装异步操作并可以获取其成功或失败的结果
    ①构造函数
    var a = new Promise(function(resolve,reject){
        resolve(value)//将Promise对象状态变为成功
        reject(reason)//将状态变为失败
    })
    ②then方法
    a.then(function(value){
        //Promise对象成功时调用，value就是resolve中传递的value
    },function(reason){
        //Promise对象失败时调用，reason就是resolve中传递的reason
    })
    then方法的返回值是一个Promise对象，对象的状态由回调函数的执行结果决定，所以可以进行链式调用
      1.如果回调函数中返回的结果是非Promise类型的数据，状态为成功，返回值为对象成功的值(value)
      2.如果是Promise对象，由返回的Promise对象的状态决定,返回值就是Promise对象成功或失败的值
      3.抛出错误，则Promise对象就是失败的，失败的值就是抛出错误的值
    ③catch方法
      Promise失败时调用catch内的回调函数
    
14.Set
    ES6提供了新的数据类型Set(集合)，它类似于数组，但是成员的值都是唯一的，可以使用...运算符和for...of
    属性和方法：
      size  返回集合的元素个数
      add   增加一个新元素，返回当前集合
      delete 删除元素，返回布尔值
      has  检测集合中是否存在值，返回布尔值
      clear 清空
    1.声明一个Set
      let a = new Set()
      let b = new Set(1,2,3)
    2.应用
    ①数组去重
    格式：
    let result = [...new Set(数组对象)];
    
15、Map
    ES6提供了Map数据结构，它类似于对象，也可以是键值对的集合，但键的范围不限于字符串，
      各种类型的值都可以作为键,可以使用...和for...of
    属性和方法：
      size 返回元素个数
      set() 增加新元素
      get() 返回键对应的值
      delete() 删除元素
      has() 检测是否含有该键
      clear() 清空元素
    声明Map对象
    let a = new Map();
    let a = new Map([1,2],[2,{}]);
    
16.Class
    语法：
    class 类名{
        //静态属性,非必须
        //静态属性只有class构造函数本身能读取，实例化的对象无法读取这个属性
        static 属性名 = 属性值;
        //属性
        constructor(){
            //code
        }
        //方法
        方法名(){
            //code
        }
    }
    可以使用extends来继承其他class类的属性与方法，
    语法：class 类名 extends 继承类名{
        constructor(){
            super()//可以调用继承的class类的同名方法constructor，就是可以调用父类的constructor方法
        }
        say{
            super.say()//可以调用父类上的say方法
        }
    }
    get
        可以在一个方法读取时就被调用
        get 方法名(){}
    set
        可以在一个方法被修改时调用
    
    示例：
    class Father{
        static name = 'father';
        constructor(name){
            this.name = name;
       }
    } 
    class Son extends Father{
        constructor(name){
            super(name)
            //此时Son创造的实例上具有name属性
        }
    }
    const a = new Father('a');
    /*a.name => 'a'
    * Father.name => 'father';
    */
    
17.数值扩展
    0. Number.EPSILON  是JavaScript中最小精度的数字，接近于2.220446...16E-16
    1. Math.isFinite  检测一个数值是否是有限数值
    2. Math.isNaN,Math.parseInt(),Math.parseFloat()  作用不变
    3. Number.isInteger  检测一个数值是否是整数
    4. Math.trunc 将小数部分抹去
    5. Math.sign  检测一个数值是正数 负数 还是0  分别返回1,-1,0
    
18.对象方法拓展
    Object.is() 检测两个值是否完全相等
    Object.assign(被覆盖对象，覆盖的对象)  对象的合并
    Object.setPrototypeOf(被设置对象，设置上去的对象),Object.getPrototypeOf() 获取或设置原型属性，没啥用
    
②ES7
1.数组操作
    includes(key)
      检查数组中是否含有某个元素,返回布尔值
2.**运算符
    和Math.pow()效果一样
    示例：2**2// 2的2次幂，结果是4
    
③ES8
1.async函数
    async函数特点
    1.函数返回值是一个Promise对象
    2.Promise对象状态有async函数执行的返回值决定，规则与then方法一样
    构造async函数：
      async function fun(){
    
      }
    
2.await表达式
    特点：
      1.await必须写在async函数内
      2.await右侧的表达式一般为Promise对象
      3.await返回的值是promise对像成功的值
      4.await后面的promise失败了，就会抛出异常，需要用try...catch捕获处理
    示例：
    let p = new Promise(function(resolve,reject){
        resolve('Success!');
    });
    let m = new Promise(function(resolve,reject){
        resolve('Fail!');
    });
    async function fun(){
        let result = await p;  //此时result为'Success!';
    }
    try{
        async function fun(){
            let result = await m;  //此时result为'Success!';
        }
    }catch(e){
        //此时e为抛出错误 'Fail!'
    }
    
3.对象拓展
    1.Object.keys(object)
      获取对象所有的键值，以数组的形式返回
    2.Object.values(object)
      获取对象所有的键值，以数组的形式返回
    3.Object.entries(object)
      获取对象所有的键和值，每组都是数组的形式返回
      用途：创建map  let a = new Map(Object.entries({a:1,b:2}));
    4.Object.getOwnPropertyDescriptors(object)
      返回对象属性的描述对象
    5.Obiect.create(原型,对象属性)
      对象属性格式：{
        键:{
            描述属性:值
        }
      }
      描述属性：
          value 值
          writable 是否可写
          configurable 是否可删除
          enumerable 是否可枚举
    
④ES9
  1.对象展开 rest和...
    (1)rest
      用于在函数参数中对象解构赋值时将传入的没有形参对应的实参保存
    示例：
    function fun({name,age,...rest}){
        console.log(rest)//此时rest就是gender和money属性组成的对象{gender:'女',money:100000}
    }
    fun({name:'爸爸',age:18,gender:'女',money:100000});
    (2)...运算
      能将对象展开
    示例：
    const obj = {
        x:'小明',
        h:'小红'
    }
    const obi2 = {
        g:'小刚'
    }
    //...obj =>  x:'小明',h:'小红'
    const student = {...obj,...obj2};
    //此时student => {
        x:'小明',
        h:'小红',
        g:'小刚'
    }
    
2.正则扩展
  (1)命名捕获分组
    从前的方法：
    ()来进行正则分组
    reg.exec可以获取分组结果
    示例：
      let reg = /www\.(.*)\.com/
      let str = "www.lws.com";
      reg.exec(str);
      //输出结果为{0:www.lws.com,1:lws}
    新方法：
      使用?<名字>进行分组
      此时使用exec输出的对象中的group值中含有这个名字的分组
      示例：let reg = /www\.(?<url>.*)\.com/
  (2)反向断言
    正向断言
      根据后面跟的东西来判断找到的字符是否正确,使用(?=条件)增加条件
      示例：
      let reg = /www\.(.*)\.com(?=/1.html)/
      let str = "www.lws.com/1.html";//此时符合正则
      let str = "www.hjj.com/1.htm/www.lws.com";//此时不符合正则
    反向断言
      根据前面的内容进行判断，使用(?<=条件)进行判断
3.dotAll模式
    s 表示 dotAll模式,.可以匹配任意字符
    创建方式：//s
    
⑤ES10
  1.Object.fromEntries()
    用于创建对象，接受二维数组或Map
    示例：
    let obj = Object.fromEntries([
        [name,'小明'],
        [age:118]
    ]);
  2.字符串方法扩展
    (1)trimStart
      清除字符串左侧空白
    (2)trimEnd
      清除字符串右侧空白
  3.数组方法扩展
    (1)flat(number)
      将多维数组转化为低维数组
      参数：number  表示展开次数
    (2)flatMap
      将map和flat结合
  4.Symbol.description
    获取Symbol的字符串描述

⑥ES11
    1.私有属性
      在属性前加入#是私有属性，只能在类的内部读取，类的外部无法读取到
      class Person{
          #age;
          constructor(age){
              this.#age = age;
          }
          say(){
              console.log(this.#age);
          }
      }
      const xiaoming = new Person(118);
      //xiaoming.#age  调用会报错
      //xiaoming.say() 不会报错
    2.Promise.allSettled()
      传入数组，数组每个成员都为Promise对象，返回Promise对象，状态为成功，成功值为数组，数组内成员为传入的Primise对象的结果
      与Promise.all类似，只不过all的返回结果根据传入Promise对象状态决定，都成功才为成功
    3.String.matchAll方法
      可以通过正则匹配所有符合的结果，返回一个可迭代对象，可以使用for...of进行遍历
    4.可选链操作符
      ?.
      示例：
        let o = {a:{b:{c:1}}}
        //读取c
        a?.b?.c//表示判断a中是否有b，有b再读取b，再判断b中是否有c,有c再读取c
    5.BigIng 大整数
      可以进行大数据运算，只能和相同数据类型相加
      表示方式：数字n
        示例：let n = 123n;
      BigInt(Number)函数
        可以将普通数字转换为大整形数字
    6.globalThis
        始终指向全局对象

十九、Ajax
    通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据
    1.HTTP
    HTTP协议规定了万维网服务器之间互相通信的规则
    (1)请求报文
    重点是格式和参数
    行  格式：请求方式(GET/POST) / URL HTTP/1.1(HTTP协议版本)
    头  格式：名字: 值(空格必须有)
    示例：
        Host: player.alicdn.com
        Cookie: name=lws
        Content-type: application/x-www-form-urlenconde
        User-Agent: chrome 83
    空行
    体
    (2)响应报文
    行    HTTP协议版本(HTTP1.1) 响应状态码(200) 状态字符串(OK)
    头    与请求报文相同
    空行
    体    响应返回的内容
    示例:
    <html>
        <head></head>
        <body></body>
    </html>
    2.Ajax请求的基本操作
      1.创建对象
      const xhr = new XMLHttpRequest();
      2.初始化 设置请求方法和url
      xhr.open('GET','http://player.alicdn.com');
      3.发送
      xhr.send();
      4.事件绑定 处理服务端返回的结果
      xhr.onreadystatechange = function(){
          if(xhr.readystate == 4){
              //服务端已经返回所有结果
              if(xhr.status >= 200 && xhr.status < 300){
                  //请求成功，处理结果
                  //1.响应行
              }
          }
      }
      xhr对象
      属性
        readystate  是 xhr 对象中的属性，表示请求状态，值有五个，是  0 1 2 3 4
        status  响应状态码，以2开头即为成功
        statusText  状态字符串
        response  响应体
      方法
        getAllResponseHeaders()  所有的响应头
        setRequestHeader(名,值)  设置请求头
    3.Ajax发送POST请求
      1.创建对象
      const xhr = new XMLHttpRequest();
      2.初始化 设置请求方法和url
      xhr.open('POST','http://player.alicdn.com');
      3.发送
      xhr.send(`123456461979491`);
      4.事件绑定 处理服务端返回的结果
      xhr.onreadystatechange = function(){
          if(xhr.readystate == 4){
              //服务端已经返回所有结果
              if(xhr.status >= 200 && xhr.status < 300){
                  //请求成功，处理结果
                  
              }
          }
      }
    
      
